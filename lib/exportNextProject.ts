import JSZip from "jszip";
import { saveAs } from "file-saver";
import { FileNode } from "@/stores/useFileSystemStore";
import { generateCodeFromTree } from "./codeGenerator";

// helper: generate package.json
function generatePackageJson(dependencies: Record<string, string>, devDependencies: Record<string, string>) {
  return JSON.stringify(
    {
      name: "exported-nextjs-project",
      version: "1.0.0",
      private: true,
      scripts: {
        dev: "next dev",
        build: "next build",
        start: "next start",
        lint: "next lint",
      },
      dependencies: dependencies,
      devDependencies: devDependencies,
    },
    null,
    2
  );
}


// tsconfig.json
function generateTsConfig() {
  return JSON.stringify(
    {
      compilerOptions: {
        target: "es5",
        lib: ["dom", "dom.iterable", "esnext"],
        allowJs: true,
        skipLibCheck: true,
        strict: true,
        forceConsistentCasingInFileNames: true,
        noEmit: true,
        esModuleInterop: true,
        module: "esnext",
        moduleResolution: "node",
        resolveJsonModule: true,
        isolatedModules: true,
        jsx: "preserve",
        incremental: true,
      },
      include: ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
      exclude: ["node_modules"],
    },
    null,
    2
  );
}
 //tailwindconfig.json
function generateTailwindConfig() {
  return `/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./app/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}"
  ],
  theme: { extend: {} },
  plugins: [],
};
`;
}


function generatePostcssConfig() {
  return `module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
`;
}

function generateGlobalsCss() {
  return `@tailwind base;
@tailwind components;
@tailwind utilities;`;
}

function generateLayoutTsx() {
  return `"use client";
import './globals.css';
import { useEffect } from 'react';

export const metadata = {
  title: 'Exported Project',
  description: 'Generated by Website Builder',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  useEffect(() => {
    const closeButtons = document.querySelectorAll('[data-slot="alert-close"]');
    closeButtons.forEach(button => {
      button.addEventListener('click', () => {
        const alert = button.closest('[data-slot="alert"]');
        if (alert) {
          alert.style.display = 'none';
        }
      });
    });

    const links = document.querySelectorAll('a');
    links.forEach(link => {
        const href = link.getAttribute('href');
        if (href && href.startsWith('#')) {
            const alertId = href.substring(1);
            const alert = document.getElementById(alertId);
            if (alert) {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    alert.style.display = 'block';
                });
            }
        }
    });

  }, []);

  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
`;
}

function generateGitignore() {
    return `
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
`;
}



export async function exportNextProject(root: FileNode, dependencies: Record<string, string>, devDependencies: Record<string, string>) {
  const zip = new JSZip();

  // Core config files
  zip.file("package.json", generatePackageJson(dependencies, devDependencies));
  zip.file("tsconfig.json", generateTsConfig());
  zip.file("tailwind.config.js", generateTailwindConfig());
  zip.file("postcss.config.js", generatePostcssConfig());
  zip.file("next.config.js", `/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
};

module.exports = nextConfig;`);
  zip.file("next-env.d.ts", `/// <reference types="next" />\n/// <reference types="next/types/global" />`);
  zip.file("README.md", "# Exported Next.js Project\nRun with:\n\n```bash\nnpm install\nnpm run dev\n```");
  zip.file(".gitignore", generateGitignore());

  // Project folders
  const appFolder = zip.folder("app");
  const compFolder = zip.folder("components");
  const publicFolder = zip.folder("public");
  const publicFiles = ["file.svg", "globe.svg", "next.svg", "vercel.svg", "window.svg"];

  for (const file of publicFiles) {
    const response = await fetch(`/public/${file}`);
    const blob = await response.blob();
    publicFolder?.file(file, blob);
  }

  // Add layout.tsx and globals.css to app folder
  appFolder?.file("layout.tsx", generateLayoutTsx());
  appFolder?.file("globals.css", generateGlobalsCss());


  // Find index.tsx and components
  const findFiles = (node: FileNode) => {
    if (node.type === "file") {
      if (node.name === "index.tsx") {
        appFolder?.file("page.tsx", generateCodeFromTree(node.canvasTree || []));
      } else if (node.isCustomComponent) {
        compFolder?.file(node.name, generateCodeFromTree(node.canvasTree || []));
      }
    }
    node.children?.forEach(findFiles);
  };

  findFiles(root);

  // Generate zip
  const content = await zip.generateAsync({ type: "blob" });
  saveAs(content, "nextjs-project.zip");
}